<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Unbiased Estimation</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-B8G2041HSB"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-B8G2041HSB', { 'anonymize_ip': true});
</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../assets/styles.css">
</head>

<body class="nav-sidebar docked">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
      <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item">
      Stat 210a
      </li></ol></nav>
      <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
      </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header sidebar-header-stacked">
      <a href="../index.html" class="sidebar-logo-link">
      <img src="../assets/stat_bear.png" alt="" class="sidebar-logo py-0 d-lg-inline d-none">
      </a>
    <div class="sidebar-title mb-0 py-0">
      <a href="../">Stat 210a</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/berkeley-stat210a/fall-2024" rel="" title="" class="quarto-navigation-tool px-1" aria-label=""><i class="bi bi-github"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Home / Schedule</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">Course Logistics</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../faq.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Frequently Asked Questions</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../syllabus.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Syllabus</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../calendar.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Calendar</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../handwritten-notes.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Handwritten notes</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true">
 <span class="menu-text">Course Reader</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../reader/introduction.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Course introduction</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../reader/measure-theory-basics.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Measure Theory Basics</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../license.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">License</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#outline" id="toc-outline" class="nav-link active" data-scroll-target="#outline"><span class="header-section-number">1</span> Outline</a></li>
  <li><a href="#unbiased-estimation" id="toc-unbiased-estimation" class="nav-link" data-scroll-target="#unbiased-estimation"><span class="header-section-number">2</span> Unbiased Estimation</a></li>
  <li><a href="#convex-loss-functions" id="toc-convex-loss-functions" class="nav-link" data-scroll-target="#convex-loss-functions"><span class="header-section-number">3</span> Convex Loss Functions</a></li>
  <li><a href="#the-rao-blackwell-theorem" id="toc-the-rao-blackwell-theorem" class="nav-link" data-scroll-target="#the-rao-blackwell-theorem"><span class="header-section-number">4</span> The Rao-Blackwell Theorem</a></li>
  <li><a href="#umvu-estimators" id="toc-umvu-estimators" class="nav-link" data-scroll-target="#umvu-estimators"><span class="header-section-number">5</span> UMVU estimators</a></li>
  <li><a href="#finding-the-umvue" id="toc-finding-the-umvue" class="nav-link" data-scroll-target="#finding-the-umvue"><span class="header-section-number">6</span> Finding the UMVUE</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Unbiased Estimation</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<p><span class="math display">\[
\newcommand{\cB}{\mathcal{B}}
\newcommand{\cF}{\mathcal{F}}
\newcommand{\cN}{\mathcal{N}}
\newcommand{\cP}{\mathcal{P}}
\newcommand{\cX}{\mathcal{X}}
\newcommand{\EE}{\mathbb{E}}
\newcommand{\PP}{\mathbb{P}}
\newcommand{\RR}{\mathbb{R}}
\newcommand{\ZZ}{\mathbb{Z}}
\newcommand{\td}{\,\textrm{d}}
\newcommand{\simiid}{\stackrel{\textrm{i.i.d.}}{\sim}}
\newcommand{\eqas}{\stackrel{\textrm{a.s.}}{=}}
\newcommand{\eqPas}{\stackrel{\cP\textrm{-a.s.}}{=}}
\newcommand{\eqmuas}{\stackrel{\mu\textrm{-a.s.}}{=}}
\newcommand{\eqD}{\stackrel{D}{=}}
\newcommand{\indep}{\perp\!\!\!\!\perp}
\DeclareMathOperator*{\minz}{minimize\;}
\newcommand{\Var}{\textnormal{Var}}
\newcommand{\Cov}{\textnormal{Cov}}
\newcommand{\Corr}{\textnormal{Corr}}
\]</span></p>
<div class="callout callout-style-default callout-caution callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Under construction
</div>
</div>
<div class="callout-body-container callout-body">
<p>Check that examples and proofs are complete and accurate.</p>
<p>Add link to Lecture 2</p>
</div>
</div>
<section id="outline" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="outline"><span class="header-section-number">1</span> Outline</h2>
<ol type="1">
<li>Convex Loss</li>
<li>Rao-Blackwell Theorem</li>
<li>UMVU Estimators</li>
<li>Examples</li>
</ol>
</section>
<section id="unbiased-estimation" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="unbiased-estimation"><span class="header-section-number">2</span> Unbiased Estimation</h2>
<p>Recall from Lecture 2 that we had two primary strategies to choose an estimator:</p>
<ol type="1">
<li>Summarize the risk function by a scalar (average or supremum)</li>
<li>Restrict attention to a smaller class of estimators</li>
</ol>
<p>Today we’ll discuss <em>unbiased estimation</em>, which is an example of the second strategy. That is, if <span class="math inline">\(g(\theta)\)</span> is our estimand, we will require that <span class="math inline">\(\EE_\theta \delta = g(\theta)\)</span> for all <span class="math inline">\(\theta\)</span></p>
<p>Unbiased estimation is especially convenient in models with a complete sufficient statistic <span class="math inline">\(T(X)\)</span>. In that case:</p>
<ul>
<li>There is at most one unbiased <span class="math inline">\(\delta(T(X))\)</span> (if <span class="math inline">\(\delta_1, \delta_2(T)\)</span> are both unbiased, then <span class="math inline">\(\delta_1 \eqas \delta_2\)</span>)</li>
<li>If an unbiased estimator exists, it <strong>uniformly minimizes</strong> risk for any convex loss function</li>
</ul>
</section>
<section id="convex-loss-functions" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="convex-loss-functions"><span class="header-section-number">3</span> Convex Loss Functions</h2>
<p>Recall <span class="math inline">\(f(y)\)</span> is <em>convex</em> if for all <span class="math inline">\(x_1, x_2\)</span> and all <span class="math inline">\(\gamma \in [0,1]\)</span>:</p>
<p><span class="math display">\[f(\gamma x_1 + (1-\gamma)x_2) \leq \gamma f(x_1) + (1-\gamma) f(x_2)\]</span> <span class="math inline">\(f\)</span> is <em>strictly convex</em> if the inequality is strict unless <span class="math inline">\(x_1 = x_2\)</span>.</p>
<p>An key fact about convex functions is <strong>Jensen’s Inequality:</strong> If <span class="math inline">\(f\)</span> is convex, then for <em>any</em> random variable <span class="math inline">\(X\)</span>, we have</p>
<p><span class="math display">\[f(\EE[X]) \leq \EE[f(X)]\]</span> If <span class="math inline">\(f\)</span> is strictly convex, then the inequality is strict unless <span class="math inline">\(X\)</span> is constant.</p>
<p>We say a loss function <span class="math inline">\(L(\theta, d)\)</span> is (strictly) convex if is (strictly) convex as a function of the estimate <span class="math inline">\(d\)</span>, its second argument, holding the parameter <span class="math inline">\(\theta\)</span> fixed.</p>
<p><strong>Example:</strong> The best-known example of a convex loss function is the squared error loss. Recall that the corresponding risk, the MSE, can be decomposed as the sum of the bias squared and the variance:</p>
<p><span class="math display">\[
\begin{aligned}
\text{MSE}_\theta(\delta) &amp;= \EE_\theta[(\delta(X) - g(\theta))^2] \\[5pt]
&amp;= \text{Bias}_\theta(\delta)^2 + \text{Var}_\theta(\delta(X))
\end{aligned}
\]</span> If <span class="math inline">\(\delta(X)\)</span> is unbiased, then its MSE is exactly its variance, so minimizing the risk among unbiased estimators just amounts to finding one with the least variance.</p>
</section>
<section id="the-rao-blackwell-theorem" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="the-rao-blackwell-theorem"><span class="header-section-number">4</span> The Rao-Blackwell Theorem</h2>
<p>Intuitively, convex losses punish us for using noisy estimators: we would always improve the risk if we could replace an estimator <span class="math inline">\(\delta(X)\)</span> with its expectation: <span class="math display">\[L(\theta, \EE_\theta [\delta(X)]) \leq \EE_\theta \left[L(\theta, \delta(X))\right].\]</span>Generally, this is not feasible in real problems because <span class="math inline">\(\EE_\theta [\delta(X)]\)</span> depends on <span class="math inline">\(\theta\)</span>, so it is not an estimator. But for any sufficient statistic <span class="math inline">\(T(X)\)</span>, the <strong>conditional expectation</strong> of <span class="math inline">\(\delta(X)\)</span> given <span class="math inline">\(T(X)\)</span> really is an estimator, and it is always at least as good as <span class="math inline">\(\delta(X\)</span>) if the loss is convex.</p>
<p>The next result formalizes this fact, and thereby gives decision-theoretic teeth to the sufficiency principle:</p>
<p><strong>Theorem (Rao-Blackwell):</strong> Let <span class="math inline">\(T(X)\)</span> be sufficient for <span class="math inline">\(\cP = \{P_\theta:\;\theta\in\Theta\}\)</span>, and let <span class="math inline">\(\delta(X)\)</span> be any estimator for <span class="math inline">\(g(\theta)\)</span>. Define the new estimator:</p>
<p><span class="math display">\[\bar{\delta}(T(X)) = \EE[\delta(X) \mid T(X)]\]</span></p>
<p>Then for any convex loss <span class="math inline">\(L(\theta, d)\)</span>, we have <span class="math inline">\(R(\theta, \bar{\delta}) \leq R(\theta, \delta)\)</span> for all <span class="math inline">\(\theta\)</span>. If <span class="math inline">\(L\)</span> is strictly convex, <span class="math inline">\(\bar{\delta}\)</span> strictly dominates <span class="math inline">\(\delta\)</span> as an estimator unless <span class="math inline">\(\delta(X) \eqPas \bar{\delta}(T(X))\)</span>.</p>
<p><em>Proof:</em></p>
<p><span class="math display">\[\begin{aligned}
R(\theta, \bar{\delta}) &amp;= \EE_\theta\left[\,L(\theta, \;\EE[\delta \mid T])\,\right]\\[5pt]
&amp;\leq \EE_\theta\left[\,\EE[L(\theta, \delta) \mid T]\,\right]\\[5pt]
&amp;= \EE_\theta[\,L(\theta, \delta)\,] \\[5pt]
&amp;= R(\theta, \bar{\delta})
\end{aligned}\]</span></p>
<p><span class="math inline">\(\bar{\delta}\)</span> is called the Rao-Blackwellization of <span class="math inline">\(\delta\)</span>. Note that the condition $\delta(X) \eqPas \bar{\delta}(T(X))$ is equivalent to the condition that <span class="math inline">\(\delta\)</span> depends only on <span class="math inline">\(X\)</span> through <span class="math inline">\(T(X)\)</span>.</p>
<p>Whenever we are dealing with a convex loss, the Rao-Blackwell theorem lets us restrict our attention only to estimators that run through <span class="math inline">\(T(X)\)</span>, because any other estimator could be improved (or at least not worsened) by Rao-Blackwellization. The theorem even gives us a recipe for **constructing** the improved estimator.</p>
</section>
<section id="umvu-estimators" class="level2" data-number="5">
<h2 data-number="5" class="anchored" data-anchor-id="umvu-estimators"><span class="header-section-number">5</span> UMVU estimators</h2>
<p>In this section we will combine two key facts from this lecture and last concerning unbiased estimation of any estimand <span class="math inline">\(g(\theta)\)</span>.</p>
<ol type="1">
<li>If <span class="math inline">\(T(X)\)</span> is complete sufficient, there can be at most one unbiased estimator based on <span class="math inline">\(T(X)\)</span>.</li>
<li>If the loss is convex, then we can restrict our attention only to estimators that are based on <span class="math inline">\(T(X)\)</span>.</li>
</ol>
<p>Together these facts imply that, if any unbiased estimator exists at all, then there is a unique best unbiased estimator.</p>
<p>Not all estimands have unbiased estimators. We say <span class="math inline">\(g(\theta)\)</span> is <em>U-estimable</em> if there exists any <span class="math inline">\(\delta(X)\)</span> with <span class="math inline">\(\EE_\theta \delta(X) = g(\theta)\)</span> for all <span class="math inline">\(\theta\)</span>. This leads to the following theorem:</p>
<p><strong>Theorem:</strong> For model <span class="math inline">\(\mathcal{P} = \{P_\theta : \theta \in \Theta\}\)</span>, assume <span class="math inline">\(T(X)\)</span> is a complete sufficient statistic. Then</p>
<ol type="1">
<li>For any U-estimable <span class="math inline">\(g(\theta)\)</span> there exists a unique unbiased estimator of the form <span class="math inline">\(\delta(T(X))\)</span>.</li>
<li>For a (strictly) convex loss, that estimator (strictly) dominates any other unbiased estimator <span class="math inline">\(\tilde{\delta}(X)\)</span> unless <span class="math inline">\(\tilde{\delta}(X) \eqas \delta(T(X))\)</span>.</li>
</ol>
<p>As usual the “uniqueness” here is only up to <span class="math inline">\(\eqPas\)</span>.</p>
<p><em>Proof:</em></p>
<p>(1) Since <span class="math inline">\(g(\theta)\)</span> is U-estimable, there exists some unbiased estimator <span class="math inline">\(\delta_0(X)\)</span>. Then its Rao-Blackwellization <span class="math inline">\(\delta(T(X)) = \EE[\delta_0 \mid T]\)</span> is also unbiased, since</p>
<p><span class="math display">\[
\EE_\theta \delta(T) = \EE_\theta[\EE[\delta_0 | T]] = \EE_\theta \delta_0 = g(\theta).
\]</span></p>
<p>Any other estimator of the form <span class="math inline">\(\tilde\delta(T)\)</span> must be almost surely equal to <span class="math inline">\(\delta(T)\)</span>, by completeness: if <span class="math inline">\(f(t) = \delta(t)-\tilde\delta(t)\)</span>, then both estimators being unbiased means <span class="math inline">\(\EE_\theta f(T) = g(\theta)-g(\theta) = 0\)</span>, so <span class="math inline">\(f(T(X)) \eqas 0\)</span>. Thus, <span class="math inline">\(\delta(T)\)</span> is unique.</p>
<p>(2) The first result implies that every unbiased estimator has the same Rao-Blackwellization, namely <span class="math inline">\(\delta(T)\)</span>. Thus, by the Rao-Blackwell theorem, <span class="math inline">\(\delta(T)\)</span> (strictly) dominates every other unbiased estimator for any (strictly) convex loss function, unless the estimator is almost surely identical to <span class="math inline">\(\delta\)</span>. <span class="math inline">\(\blacksquare\)</span></p>
<p>The estimator from this theorem is usually called the <em>UMVU (Uniformly Minimum Variance Unbiased) Estimator</em>. We say <span class="math inline">\(\delta(X)\)</span> is UMVU if:</p>
<ol type="1">
<li><span class="math inline">\(\delta(X)\)</span> is unbiased</li>
<li><span class="math inline">\(\text{Var}_\theta \,\delta(X) \leq \text{Var}_\theta \,\tilde{\delta}(X)\)</span> for all <span class="math inline">\(\theta\)</span> and all unbiased <span class="math inline">\(\tilde{\delta}(X)\)</span></li>
</ol>
<p>Since <span class="math inline">\(\text{MSE}(\theta; \delta) = \text{Var}_\theta(\delta(X))\)</span> for any unbiased estimator, and the squared error loss is strictly convex, Theorem XXX immediately implies the existence of a unique UMVU estimator for any U-estimable <span class="math inline">\(g(\theta)\)</span>, whenever we have a complete sufficient statistic.</p>
<p>Note that in problems where no complete sufficient statistic exists, there can be multiple unbiased estimators based on the minimal sufficient statistic; for example, both the mean and the median are unbiased for the Laplace location parameter, but they are not almost surely equal to each other, and they do not have the same risk function.</p>
</section>
<section id="finding-the-umvue" class="level2" data-number="6">
<h2 data-number="6" class="anchored" data-anchor-id="finding-the-umvue"><span class="header-section-number">6</span> Finding the UMVUE</h2>
<p>Theorem XXX suggests two strategies for finding the UMVUE:</p>
<ol type="1">
<li>Solve directly for an unbiased estimator based on <span class="math inline">\(T\)</span></li>
<li>Find any unbiased estimator at all, then Rao-Blackwellize it</li>
</ol>
<p>We give examples of both strategies below:</p>
<p><strong>Example (Poisson):</strong> Let <span class="math inline">\(X_1, \ldots, X_n \sim \text{Pois}(\theta)\)</span>, <span class="math inline">\(g(\theta) = e^{-\theta}\)</span> and consider unbiased estimation for <span class="math inline">\(g(\theta) = \theta^2\)</span>.</p>
<p>The complete sufficient statistic for the model is</p>
<p><span class="math display">\[T(X) = \sum X_i \sim \text{Pois}(n\theta),\]</span> and its probability mass function for <span class="math inline">\(t \geq 0\)</span> is <span class="math display">\[
p_\theta(t) = \frac{e^{-n\theta} (n\theta)^t}{t!}
\]</span> <strong>Strategy 1</strong></p>
<p>If there is some unbiased estimator <span class="math inline">\(\delta(t)\)</span>, we can try to solve for it by setting its expectation equal to <span class="math inline">\(\theta^2\)</span>: <span class="math display">\[
\theta^2 = \EE_\theta \delta(T) = \sum_{t=0}^\infty \delta(t) \frac{e^{-n\theta} (n\theta)^t}{t!}.
\]</span> Rearranging factors, we obtain matching power series: <span class="math display">\[
\sum_{t=0}^\infty \delta(t) \frac{n^t \theta^t}{t!} = e^{n\theta}\theta^2 =  \sum_{k=0}^\infty \frac{n^k\theta^{k+2}}{k!}.
\]</span> We will choose the coefficients on the left-hand side to match terms. First, change the index for the left-hand sum to <span class="math inline">\(t = k+2\)</span>: <span class="math display">\[
\sum_{t=0}^\infty \delta(t) \frac{n^t \theta^t}{t!} = e^{n\theta}\theta^2 =  \sum_{t=2}^\infty \frac{n^{t-2}\theta^{t}}{(t-2)!}.
\]</span> To match the terms, we can set <span class="math inline">\(\delta(0)=\delta(1)=0\)</span>, and for <span class="math inline">\(t\geq 2\)</span>, set <span class="math inline">\(\delta(t)=\frac{t!}{n^2(t-2)!}=\frac{t(t-1)}{n^2}\)</span>. The same expression works for both, so we obtain the estimator <span class="math display">\[
\delta(T) = \frac{T(T-1)}{n^2}
\]</span></p>
<p><strong>Strategy 2:</strong></p>
<p>Alternatively, we can find an unbiased estimator and Rao-Blackwellize it. If $n$, we can use the fact that</p>
<p><span class="math display">\[
\EE_\theta [X_1 X_2] = \EE_\theta [X_1] \;\cdot\; \EE_\theta [X_2] = \theta^2
\]</span> to obtain an initial unbiased estimator <span class="math inline">\(\delta_0(X) = X_1X_2\)</span>, which we will Rao-Blackwellize.</p>
<p>Conditional on $</p>
<p>to match the terms</p>
<p><span class="math inline">\(\delta(T) = (1 - 1/n)^T\)</span> unbiased:</p>
<p><span class="math display">\[\begin{aligned}
\EE_\theta \delta(T) &amp;= \sum_{t=0}^\infty (1-1/n)^t e^{-n\theta} (n\theta)^t / t! \\
&amp;= e^{-n\theta} \sum_{t=0}^\infty ((n-1)\theta)^t / t! \\
&amp;= e^{-n\theta} e^{(n-1)\theta} = e^{-\theta}
\end{aligned}\]</span></p>
<p>Alternatively, we could Rao-Blackwellize <span class="math inline">\(\delta_0(X) = I(X_1 = 0)\)</span>:</p>
<p><span class="math display">\[\begin{aligned}
\EE[I(X_1 = 0) | T] &amp;= \PP(X_1 = 0 | T) \\
&amp;= \frac{\PP(X_1 = 0, X_2 + \cdots + X_n = T)}{\PP(X_2 + \cdots + X_n = T-1) + \PP(X_2 + \cdots + X_n = T)} \\
&amp;= \frac{\binom{n-1}{T} (1/n)^0 (1-1/n)^T}{\binom{n-1}{T-1} (1/n) (1-1/n)^{T-1} + \binom{n-1}{T} (1-1/n)^T} \\
&amp;= \frac{(1-1/n)^T}{T/n + (1-1/n)^T} \\
&amp;= (1-1/n)^T
\end{aligned}\]</span></p>
<p><strong>Example:</strong> <span class="math inline">\(X_1, \ldots, X_n \sim U[0, \theta]\)</span>, <span class="math inline">\(\theta &gt; 0\)</span></p>
<p><span class="math inline">\(T = X_{(n)}\)</span> complete sufficient</p>
<p><span class="math inline">\(p_\theta(t) = n t^{n-1} / \theta^n \cdot I(0 &lt; t &lt; \theta)\)</span></p>
<p><span class="math inline">\(\EE_\theta[T] = \frac{n}{n+1} \theta\)</span></p>
<p><span class="math inline">\(T \cdot \frac{n+1}{n}\)</span> is UMVUE</p>
<p>Alternatively, <span class="math inline">\(2X_1\)</span> is unbiased:</p>
<p><span class="math display">\[\EE[2X_1 | T] = 2T \cdot \frac{n+1}{2n} = T \cdot \frac{n+1}{n}\]</span></p>
<p>Actually, <span class="math inline">\(T\)</span> is inadmissible too! Keener shows <span class="math inline">\(\frac{n-1}{n} T\)</span> has better MSE for any estimator <span class="math inline">\(c \cdot T\)</span>.</p>
<p>This raises the question: why do we require zero bias?</p>
<p>The UMVUE is often inefficient, inadmissible, or just dumb in cases where another approach makes much more sense.</p>
<p><strong>Example:</strong> <span class="math inline">\(X \sim \text{Bin}(1000, \theta)\)</span></p>
<p>Estimate <span class="math inline">\(g(\theta) = I(\theta &gt; 0.5)\)</span></p>
<p>UMVUE is <span class="math inline">\(I(X &gt; 500)\)</span>. Why?</p>
<ul>
<li><span class="math inline">\(X = 500\)</span>: Conclude <span class="math inline">\(g(\theta) = 1\)</span></li>
<li><span class="math inline">\(X = 499\)</span>: Conclude <span class="math inline">\(g(\theta) = 0\)</span></li>
</ul>
<p>This is not epistemically reasonable. Could do much better with e.g.&nbsp;MLE or a Bayes estimator.</p>
<p>In fact, our theorem should make us suspicious of UMVUEs: every idiotic function of <span class="math inline">\(T\)</span> is a UMVUE of its own expectation!</p>
<p><strong>Example:</strong> <span class="math inline">\(X_1, \ldots, X_n \sim N(\mu, 1)\)</span>, estimate <span class="math inline">\(g(\mu) = \|\mu\|\)</span></p>
<p><span class="math inline">\(\bar{X}\)</span> is complete sufficient</p>
<p><span class="math inline">\(\|\bar{X}\|\)</span> is unbiased: <span class="math inline">\(\EE[\|\bar{X}\|] = \EE[\|N(\mu, 1/n)\|] = \|\mu\|\)</span></p>
<p>So <span class="math inline">\(\|\bar{X}\|\)</span> is UMVUE</p>
<p>If <span class="math inline">\(\mu = 0\)</span>, <span class="math inline">\(\delta(\bar{X}) = 0\)</span> about half the time</p>
<p><span class="math inline">\(\|\bar{X}\| + d \cdot \max(0, \|\bar{X}\| - d)\)</span> strictly dominates UMVUE</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>